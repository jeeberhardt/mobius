#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# MHC-I
#

import pickle
from abc import ABC, abstractmethod
from collections import defaultdict
from multiprocessing import Pool

import numpy as np


def _number_of_children_to_generate_per_parent(parent_scores, n_children, sigma, elitism=True, greater_is_better=True):
    """Compute the number of children generated by each parent sequence 
    based on their acquisition score using RBF weighting.
    """
    i = 0
    j = 0
    
    # Handle case when there is only one parent
    if len(parent_scores) == 1:
        children_per_parent = np.array([n_children]).astype(int)
        
        if elitism:
            children_per_parent -= 1
        
        return children_per_parent
    
    # Handle the case when parents have all the same score
    if np.all(parent_scores == parent_scores[0]):
        print('Warning: All parents have the same score (%.3f)' % parent_scores[0])

        children_per_parent = np.ones(parent_scores.shape[0]).astype(int)
        children_per_parent[0] = n_children
        
        if elitism:
            children_per_parent -= 1
        
        return children_per_parent

    if greater_is_better == False:
        parent_scores = np.abs(parent_scores)

    # Normalize score between 0 and 1 because of the exponential
    p = (parent_scores - np.min(parent_scores)) / (np.max(parent_scores) - np.min(parent_scores))
    # RBF weighting
    children_per_parent = n_children * np.exp(p**2 / (2 * sigma**2)) / np.sum(np.exp(p**2 / (2 * sigma**2)))
    children_per_parent = np.floor(children_per_parent).astype(int)
    
    if elitism:
        # All the parents with less than two children are disqualified in elistism mode
        # because we will need to substract 1 at the end
        children_per_parent[children_per_parent < 2] = 0
    
    parent_indices = np.argwhere(children_per_parent > 0).flatten()
    
    # Add 1 until the number of children is equal to n_children
    while np.sum(children_per_parent) < n_children:
        try:
            if children_per_parent[parent_indices[i]] > 0:
                children_per_parent[parent_indices[i]] += 1
            i += 1
        except:
            # we restart from the beginning if we reach the end
            i = 0
        
        if j >= parent_scores.shape[0]:
            print('Warning: Might be stuck in infinite loop!!')
            print(parent_scores)
            print(children_per_parent)
        
        j += 1
    
    if elitism:
        # Here we substract 1 in order to take account of the parent that we keep
        children_per_parent[children_per_parent > 1] -= 1

    return children_per_parent


class _GeneticAlgorithm(ABC):
    """Abstract class for genetic algorithm brick"""

    @abstractmethod
    def _generate_new_population(self, sequences, scores):
        pass

    @abstractmethod
    def run(self, scoring_function, sequences, scores=None):
        all_sequences = []
        all_sequence_scores = []
        
        self._scoring_function = scoring_function
        
        # Evaluate the initial population
        if scores is None:
            scores = self._scoring_function.evaluate(sequences)

        for i in range(self._n_gen):
            # Generate new population
            sequences = self._generate_new_population(sequences, scores)
            # Remove duplicates
            # That is inefficient because there is a strong chance that will have less than NIND children...
            sequences = np.unique(sequences)
            # Evaluate the population
            scores = self._scoring_function.evaluate(sequences)

            all_sequences.extend(sequences)
            all_sequence_scores.extend(np.ravel(scores))

        # Remove duplicates
        all_sequences, unique_indices = np.unique(all_sequences, return_index=True)
        all_sequence_scores = np.array(all_sequence_scores)[unique_indices]
        
        # Sort sequences by scores in the decreasing order (best to worst)
        if self._scoring_function.greater_is_better:
            sorted_indices = np.argsort(all_sequence_scores)[::-1]
        else:
            sorted_indices = np.argsort(all_sequence_scores)
        
        self.sequences = all_sequences[sorted_indices]
        self.scores = all_sequence_scores[sorted_indices]
        
        return self.sequences, self.scores


class SequenceGA(_GeneticAlgorithm):

    def __init__(self, helmgo, **parameters):
        self._helmgo = helmgo
        self._n_gen = parameters['n_gen']
        self._n_children = parameters['n_children']
        self._sigma = parameters['sigma']
        self._elitism = parameters['elitism']
        self._scoring_function = None

    def _generate_new_population(self, sequences, scores):
        new_pop = []

        # Compute the number of children generated by each parent sequence based on their acquisition score
        children_per_parent = _number_of_children_to_generate_per_parent(scores, self._n_children, self._sigma, self._elitism, self._scoring_function.greater_is_better)

        parent_indices = np.argwhere(children_per_parent > 0).flatten()

        for i in parent_indices:
            if self._elitism:
                new_pop.append(sequences[i])
            
            new_pop.extend(self._helmgo.mutate(sequences[i], n=children_per_parent[i], minimum_mutations=1, maximum_mutations=2))

        return new_pop

    def run(self, scoring_function, sequences, scores=None):
        self.sequences, self.scores = super().run(scoring_function, sequences, scores)
        print('End sequence opt - Score: %5.3f - Seq: %d - %s' % (self.scores[0], self.sequences[0].count('.'), self.sequences[0]))

        return self.sequences, self.scores


class ScaffoldGA(_GeneticAlgorithm):

    def __init__(self, helmgo, **parameters):
        self._helmgo = helmgo
        self._n_gen = parameters['n_gen']
        self._n_children = parameters['n_children']
        self._sigma = parameters['sigma']
        self._elitism = parameters['elitism']
        self._probability = parameters['probability'] # 25
        self._only_terminus = parameters['only_terminus'] # True
        self._minimum_size = parameters['minimum_size'] # 8
        self._maximum_size = parameters['maximum_size'] # 11
        self._scoring_function = None

    def _generate_new_population(self, sequences, scores):
        new_pop = []
        
        # Compute the number of children generated by each parent sequence based on their acquisition score
        children_per_parent = _number_of_children_to_generate_per_parent(scores, self._n_children, self._sigma, self._elitism, self._scoring_function.greater_is_better)

        parent_indices = np.argwhere(children_per_parent > 0).flatten()
        
        for i in parent_indices:
            tmp = []
            
            if self._elitism:
                new_pop.append(sequences[i])
            
            actions = np.random.choice(['insert', 'remove'], size=children_per_parent[i])
            
            tmp.extend(self._helmgo.insert(sequences[i], np.sum(actions == "insert"), self._probability, self._only_terminus, self._maximum_size))
            tmp.extend(self._helmgo.remove(sequences[i], np.sum(actions == "remove"), self._probability, self._only_terminus, self._minimum_size))
            tmp = [self._helmgo.mutate(t, n=1, minimum_mutations=1, maximum_mutations=2)[0] for t in tmp]
            
            new_pop.extend(tmp)

        return new_pop

    def run(self, scoring_function, sequences, scores=None):
        self.sequences, self.scores = super().run(scoring_function, sequences, scores)
        print('End scaffold opt - Score: %5.3f - Seq: %d - %s' % (self.scores[0], self.sequences[0].count('.'), self.sequences[0]))

        return self.sequences, self.scores


class GA():
    
    def __init__(self, helmgo, **parameters):
        self._helmgo = helmgo
        self._n_gen = parameters['n_gen']
        self._seq_gao_parameters = {k.replace('sequence_', ''): v for k, v in parameters.items() if 'sequence' in k}
        self._sca_gao_parameters = {k.replace('scaffold_', ''): v for k, v in parameters.items() if 'scaffold' in k}
        self._scoring_function = None
        
    def run(self, scoring_function, sequences, scores=None):
        all_sequences = []
        all_sequence_scores = []
        
        # So apparently, scoring function is unpicklable once you used it
        # so I have to dump it before... stupid.
        pickle.dump(scoring_function, open("save.pkl", "wb"))
        
        sca_gao = ScaffoldGA(self._helmgo, **self._sca_gao_parameters)
        seq_gao = SequenceGA(self._helmgo, **self._seq_gao_parameters)
        
        # Evaluate the initial population
        if scores is None:
            scores = scoring_function.evaluate(sequences)

        for i in range(self._n_gen):
            new_pop = []
            new_scores = []

            # Run scaffold GA first
            sequences, scores = sca_gao.run(scoring_function, sequences, scores)

            # Clustering peptides based on the length
            clusters = defaultdict(list)
            for i, sequence in enumerate(sequences):
                clusters[sequence.count('.')].append(i)

            # Load back the scoring function... *sigh*
            scoring_function = pickle.load(open("save.pkl", "rb"))

            # Dispatch peptides and run local GA opt.
            pool = Pool(processes=self._seq_gao_parameters['n_process'])
            results = pool.starmap(seq_gao.run, [(scoring_function, sequences[sequence_indices], scores[sequence_indices]) for _, sequence_indices in clusters.items()])
            pool.close()
            pool.join()

            for r in results:
                all_sequences.extend(r[0])
                all_sequence_scores.extend(r[1])
        
        # Remove duplicates
        all_sequences, unique_indices = np.unique(all_sequences, return_index=True)
        all_sequence_scores = np.array(all_sequence_scores)[unique_indices]
        
        # Sort sequences by scores in the decreasing order (best to worst)
        if scoring_function.greater_is_better:
            sorted_indices = np.argsort(all_sequence_scores)[::-1]
        else:
            sorted_indices = np.argsort(all_sequence_scores)
        
        self.sequences = all_sequences[sorted_indices]
        self.scores = all_sequence_scores[sorted_indices]
        
        print('End GA opt - Score: %5.3f - Seq: %d - %s' % (self.scores[0], self.sequences[0].count('.'), self.sequences[0]))
        
        return self.sequences, self.scores
