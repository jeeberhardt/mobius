#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# MHC-I
#

from abc import ABC, abstractmethod

import numpy as np


def _number_of_children_to_generate_per_parent(parent_scores, n_children, sigma, elitism=True, greater_is_better=True):
    """Compute the number of children generated by each parent sequence 
    based on their acquisition score using RBF weighting.
    """
    i = 0
    j = 0
    
    # Handle case when there is only one parent
    if len(parent_scores) == 1:
        children_per_parent = np.array([n_children]).astype(int)
        
        if elitism:
            children_per_parent -= 1
        
        return children_per_parent
    
    # Handle the case when parents have all the same score
    if np.all(parent_scores == parent_scores[0]):
        print('Warning: All parents have the same score (%.3f)' % parent_scores[0])

        children_per_parent = np.ones(parent_scores.shape[0]).astype(int)
        children_per_parent[0] = n_children
        
        if elitism:
            children_per_parent -= 1
        
        return children_per_parent

    if greater_is_better == False:
        parent_scores = np.abs(parent_scores)

    # Normalize score between 0 and 1 because of the exponential
    p = (parent_scores - np.min(parent_scores)) / (np.max(parent_scores) - np.min(parent_scores))
    # RBF weighting
    children_per_parent = n_children * np.exp(p**2 / (2 * sigma**2)) / np.sum(np.exp(p**2 / (2 * sigma**2)))
    children_per_parent = np.floor(children_per_parent).astype(int)
    
    if elitism:
        # All the parents with less than two children are disqualified in elistism mode
        # because we will need to substract 1 at the end
        children_per_parent[children_per_parent < 2] = 0
    
    parent_indices = np.argwhere(children_per_parent > 0).flatten()
    
    # Add 1 until the number of children is equal to n_children
    while np.sum(children_per_parent) < n_children:
        try:
            if children_per_parent[parent_indices[i]] > 0:
                children_per_parent[parent_indices[i]] += 1
            i += 1
        except:
            # we restart from the beginning if we reach the end
            i = 0
        
        if j >= parent_scores.shape[0]:
            print('Warning: Might be stuck in infinite loop!!')
            print(parent_scores)
            print(children_per_parent)
        
        j += 1
    
    if elitism:
        # Here we substract 1 in order to take account of the parent that we keep
        children_per_parent[children_per_parent > 1] -= 1

    return children_per_parent


class _GeneticAlgorithm(ABC):
    """Abstract class for genetic algorithm brick"""

    @abstractmethod
    def _generate_new_population(self, sequences, scores):
        pass

    @abstractmethod
    def run(self, scoring_function, sequences, scores=None):
        all_sequences = []
        all_sequence_scores = []

        self._greater_is_better = scoring_function.greater_is_better
        
        # Evaluate the initial population
        if scores is None:
            scores = scoring_function.evaluate(sequences)

        for i in range(self._n_gen):
            # Generate new population
            sequences = self._generate_new_population(sequences, scores)
            # Remove duplicates
            # That is inefficient because there is a strong chance that will have less than NIND children...
            sequences = np.unique(sequences)
            # Evaluate the population
            sequence_scores = scoring_function.evaluate(sequences)

            all_sequences.extend(sequences)
            all_sequence_scores.extend(np.ravel(sequence_scores))

        # Remove duplicates
        all_sequences, unique_indices = np.unique(all_sequences, return_index=True)
        all_sequence_scores = np.array(all_sequence_scores)[unique_indices]
        
        # Sort sequences by scores in the decreasing order (best to worst)
        if self._greater_is_better:
            sorted_indices = np.argsort(all_sequence_scores)[::-1]
        else:
            sorted_indices = np.argsort(all_sequence_scores)
        
        self.sequences = all_sequences[sorted_indices]
        self.scores = all_sequence_scores[sorted_indices]
        
        return self.sequences, self.scores


class LocalGA(_GeneticAlgorithm):

    def __init__(self, helmgo, **parameters):
        self._helmgo = helmgo
        self._n_gen = parameters['n_gen']
        self._n_children = parameters['n_children']
        self._sigma = parameters['sigma']
        self._elitism = parameters['elitism']
        self._greater_is_better = None

    def _generate_new_population(self, parents, parent_scores):
        new_pop = []

        # Compute the number of children generated by each parent sequence based on their acquisition score
        children_per_parent = _number_of_children_to_generate_per_parent(parent_scores, self._n_children, self._sigma, self._elitism, self._greater_is_better)

        parent_indices = np.argwhere(children_per_parent > 0).flatten()

        for i in parent_indices:
            if self._elitism:
                new_pop.append(parents[i])
            
            new_pop.extend(self._helmgo.mutate(parents[i], n=children_per_parent[i], minimum_mutations=1, maximum_mutations=2))

        return new_pop

    def run(self, scoring_function, sequences, scores=None):
        super().run(scoring_function, sequences, scores)
        print('End local opt - Score: %5.3f - Seq: %d - %s' % (self.candidate_scores[0], self.candidates[0].count('.'), self.candidates[0]))


class GlobalGA(_GeneticAlgorithm):

    def __init__(self, helmgo, **parameters):
        self._helmgo = helmgo
        self._n_gen = parameters['n_gen']
        self._n_children = parameters['n_children']
        self._sigma = parameters['sigma']
        self._elitism = parameters['elitism']
        self._greater_is_better = None

    def _generate_new_population(self, parents, parent_scores):
        new_pop = []

        probability = parameters['probability'] # 25
        only_terminus = parameters['only_termnus'] # True
        minimum_size = parameters['minimum_size'] # 8
        maximum_size = parameters['maximum_size'] # 11
        
        # Compute the number of children generated by each parent sequence based on their acquisition score
        children_per_parent = _number_of_children_to_generate_per_parent(parent_scores, self._n_children, self._sigma, self._elitism, self._greater_is_better)

        parent_indices = np.argwhere(children_per_parent > 0).flatten()
        
        for i in parent_indices:
            tmp = []
            
            if self._elitism:
                new_pop.append(parents[i])
            
            actions = np.random.choice(['insert', 'remove'], size=children_per_parent[i])
            
            tmp.extend(self._helmgo.insert(parents[i], np.sum(actions == "insert"), probability, only_terminus, maximum_size))
            tmp.extend(self._helmgo.remove(parents[i], np.sum(actions == "remove"), probability, only_terminus, minimum_size))
            tmp = [self._helmgo.mutate(t, n=1, minimum_mutations=1, maximum_mutations=2)[0] for t in tmp]
            
            new_pop.extend(tmp)

        return new_pop

    def run(self, scoring_function, sequences, scores=None):
        super().run(scoring_function, sequences, scores)
        print('End global opt - Score: %5.3f - Seq: %d - %s' % (self.candidate_scores[0], self.candidates[0].count('.'), self.candidates[0]))
