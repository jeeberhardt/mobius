#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Genetic algorithm
#

import os
import sys

import numpy as np
import ray
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.optimize import minimize
from pymoo.core.population import Population
from pymoo.algorithms.moo.age2 import AGEMOEA2
from pymoo.core.evaluator import Evaluator
from pymoo.core.termination import TerminateIfAny 
from pymoo.termination.max_gen import MaximumGenerationTermination
from pymoo.termination.robust import RobustTermination

from .terminations import NoChange
from .genetic_operators import Mutation, Crossover, DuplicateElimination
from ..utils import generate_random_polymers_from_designs
from ..utils import adjust_polymers_to_designs
from ..utils import group_polymers_by_scaffold


@ray.remote
def parallel_ga(gao, polymers, scores, acquisition_function, scaffold_designs):
    return gao.run(polymers, scores, acquisition_function, scaffold_designs)


class Problem(Problem):
    """
    Class to define Single/Multi/Many-Objectives SequenceGA problem.
    """

    def __init__(self, polymers, scores, acq_funs, n_inequality_constr=0, n_equality_constr=0, **kwargs):
        """
        Initialize the Single/Multi/Many-Objectives SequenceGA problem.

        Parameters
        ----------
        acq_funs : `AcquisitionFunction` or list of `AcquisitionFunction` objects
            Acquisition functions to be evaluated for each new polymer generated.
        n_inequality_constr : int, default : 0
            Number of inequality constraints.
        n_equality_constr : int, default : 0
            Number of equality constraints.
        **kwargs : dict
            Additional keyword arguments.

        """
        super().__init__(n_var=1, n_obj=len(acq_funs),
                         n_ieq_constr=n_inequality_constr,
                         n_eq_constr=n_equality_constr)

        self._prior_data = {p: s for p, s in zip(polymers, scores)}
        self._polymers_cache = {}
        if not isinstance(acq_funs, list):
            acq_funs = [acq_funs]
        self._acq_funs = acq_funs
        self._pre_evaluation = True

    def _evaluate(self, x, out, *args, **kwargs):
        """
        Function to evaluate performance of each new polymer generated.

        Parameters
        ----------
        x : ndarray of str
            Polymers generated by GA to be evaluated by the acquisition functions
        out : ndarray
            Returning objective functions' scores to be minimised by pymoo.

        """
        polymers = x.ravel()

        # Keep only unseen polymers. We don't want to reevaluate known polymers...
        to_not_evaluate_idx = np.nonzero(np.in1d(polymers, self._polymers_cache.keys()))[0]
        to_evaluate_idx = np.nonzero(~np.in1d(polymers, self._polymers_cache.keys()))[0]

        # If there is no new polymers, we skip the evaluation
        if to_evaluate_idx.size == 0:
            # But we still need to retrieve the scores of all the known polymers
            scores = np.array([self._polymers_cache[p] for p in polymers])
            scores = scores.reshape(scores.shape[0], -1)
        else:
            # For the first GA generation, we use the experimental scores
            # then we will use the acquisition scores from the surrogate models.
            # In the pre-evaluation mode, the data are not added to the cache.
            if self._pre_evaluation:
                try:
                    scores = np.array([self._prior_data[p] for p in polymers])
                except KeyError:
                    msg = f'Some polymers not found in the input experimental data. '
                    msg += 'Did you forget to turn on the eval mode?'
                    raise RuntimeError(msg)
            else:
                scores = np.zeros((len(polymers), len(self._acq_funs)))

                # Evaluate unseen polymer with acquisition scores from surrogate models
                for i, acq_fun in enumerate(self._acq_funs):
                    predictions = acq_fun.forward(polymers[to_evaluate_idx])
                    scores[to_evaluate_idx, i] = acq_fun.scaling_factor * predictions.acq

                # Complete with scores of already seen polymers
                seen_scores = np.array([self._polymers_cache[p] for p in polymers[to_not_evaluate_idx]])
                if seen_scores.size > 0:
                    scores[to_not_evaluate_idx, :] = seen_scores

                # Record acquisition score for found polymer in cache
                self._polymers_cache.update(dict(zip(polymers[to_evaluate_idx], scores[to_evaluate_idx])))

        out["F"] = scores
    
    def pre_eval(self):
        """
        Function to set pre-evaluation mode on. In pre-evaluation mode, the scores will be
        obtained from the experimental data only.

        """
        self._pre_evaluation = True

    def eval(self):
        """
        Function to set pre-evaluation mode off. In evaluation mode, the scores will be
        obtained from the surrogate models.

        """
        self._pre_evaluation = False


class SerialSequenceGA():
    """
    Class for the Single/Multi-Objectives SequenceGA optimization.

    """

    def __init__(self, algorithm='NSGA2', n_gen=1000, n_pop=250, period=50,
                 cx_points=2, pm=0.1, minimum_mutations=1, maximum_mutations=None, **kwargs):
        """
        Initialize the Single/Multi-Objectives SequenceGA optimization.

        Parameters
        ----------
        algorithm : str, default : 'NSGA2'
            Algorithm to use for the optimization. Can be 'GA' for single-objective 
            optimization, or 'NSGA2' or 'AGEMOEA2' for multi-objectives optimization.
        n_gen : int, default : 1000
            Number of GA generation to run.
        n_population : int, default : 250
            Size of the population generated at each generation.
        period : int, default : 50
            Stopping criteria. Number of attempt before stopping the search. If no
            improvement is observed after `period` generations, we stop.
        cx_points : int, default : 2
            Number of crossing over during the mating step.
        pm : float, default : 0.1
            Probability of mutation.
        minimum_mutations : int, default : 1
            Minimal number of mutations introduced in the new child.
        maximum_mutations: int, default : None
            Maximal number of mutations introduced in the new child.

        """
        self._single = {'GA': GA}
        self._multi = {'NSGA2' : NSGA2, 'AGEMOEA2': AGEMOEA2}
        self.available_algorithms = self._single | self._multi

        msg_error = f'Only {list(self.available_algorithms.keys())} are supported, not {algorithm}'
        assert algorithm in self.available_algorithms, msg_error

        self.results = None
        self.polymers = None
        self.scores = None
        # Parameters
        self._optimization = 'single' if algorithm in self._single else 'multi'
        self._parameters = {'algorithm': algorithm, 
                            'n_gen': n_gen,
                            'n_pop': n_pop, 
                            'period': period, 
                            'cx_points': cx_points, 
                            'pm': pm,
                            'minimum_mutations': minimum_mutations, 
                            'maximum_mutations': maximum_mutations}
        self._parameters.update(kwargs)
    
    def run(self, polymers, scores, acquisition_functions, scaffold_designs):
        """
        Run the Single/Multi-Objectives SequenceGA optimization.

        Parameters
        ----------
        polymers : array-like of str
            Polymers in HELM format.
        scores : array-like of float or int
            Score associated to each polymer.
        acquisition_function : `AcquisitionFunction` or list of `AcquisitionFunction` objects
            The acquisition function(s) that will be used to score the polymer.
        scaffold_designs : dictionary
            Dictionary with scaffold polymers and sets of monomers to 
            use for each position.

        Returns
        -------
        results : `pymoo.model.result.Result`
            Object containing the results of the optimization.

        """
        # Make sure that inputs are numpy arrays
        polymers = np.asarray(polymers)
        scores = np.asarray(scores)

        # Initialize the problem
        problem = Problem(polymers, scores, acquisition_functions)

        # ... and pre-initialize the population with the experimental data.
        # This is only for the first GA generation.
        X = polymers.reshape(polymers.shape[0], -1)
        pop = Population.new("X", X)
        Evaluator().eval(problem, pop)

        # Turn off the pre-evaluation mode
        # Now it will use the acquisition scores from the surrogate models
        problem.eval()

        # Initialize genetic operators
        self._mutation = Mutation(scaffold_designs, self._parameters['pm'], 
                                  self._parameters['minimum_mutations'], 
                                  self._parameters['maximum_mutations'])
        self._crossover = Crossover(self._parameters['cx_points'])
        self._duplicates = DuplicateElimination()

        # Initialize the GA method
        GA_method = self.available_algorithms[self._parameters['algorithm']]
        algorithm = GA_method(pop_size=self._parameters['n_pop'], sampling=pop, 
                       crossover=self._crossover, mutation=self._mutation,
                       eliminate_duplicates=self._duplicates)

        # Define termination criteria and make them robust to noise
        no_change_termination = RobustTermination(NoChange(), period=self._parameters['period'])
        max_gen_termination = MaximumGenerationTermination(self._parameters['n_gen'])
        termination = TerminateIfAny(max_gen_termination, no_change_termination)

        # ... and run!
        self.results = minimize(problem, algorithm, 
                                termination=termination,
                                verbose=True, save_history=True)
        
        return self.results


class SequenceGA():
    """
    Class for the Single/Multi-Objectives SequenceGA optimization.

    """

    def __init__(self, algorithm='NSGA2', n_gen=1000, n_pop=250, period=50,
                 cx_points=2, pm=0.1, minimum_mutations=1, maximum_mutations=None, 
                 n_process=-1, **kwargs):
        """
        Initialize the Single/Multi-Objectives SequenceGA optimization.

        Parameters
        ----------
        algorithm : str, default : 'NSGA2'
            Algorithm to use for the optimization. Can be 'GA' for single-objective 
            optimization, or 'NSGA2' or 'AGEMOEA2' for multi-objectives optimization.
        n_gen : int, default : 1000
            Number of GA generation to run.
        n_population : int, default : 250
            Size of the population generated at each generation.
        period : int, default : 50
            Stopping criteria. Number of attempt before stopping the search. If no
            improvement is observed after `period` generations, we stop.
        cx_points : int, default : 2
            Number of crossing over during the mating step.
        pm : float, default : 0.1
            Probability of mutation.
        minimum_mutations : int, default : 1
            Minimal number of mutations introduced in the new child.
        maximum_mutations: int, default : None
            Maximal number of mutations introduced in the new child.
        n_process : int, default : -1
            Number of process to run in parallel. Per default, use all the available core.

        """
        self._single = {'GA': GA}
        self._multi = {'NSGA2' : NSGA2, 'AGEMOEA2': AGEMOEA2}
        self.available_algorithms = self._single | self._multi

        msg_error = f'Only {list(self.available_algorithms.keys())} are supported, not {algorithm}'
        assert algorithm in self.available_algorithms, msg_error

        self.results = None
        self.polymers = None
        self.scores = None
        # Parameters
        self._n_process = n_process
        self._parameters = {'algorithm': algorithm,
                            'n_gen': n_gen,
                            'n_pop': n_pop, 
                            'period': period, 
                            'cx_points': cx_points, 
                            'pm': pm,
                            'minimum_mutations': minimum_mutations, 
                            'maximum_mutations': maximum_mutations}
        self._parameters.update(kwargs)

    def run(self, polymers, scores, acquisition_functions, scaffold_designs):
        """
        Run the Single/Multi-Objectives SequenceGA optimization.

        Parameters
        ----------
        polymers : array-like of str
            Polymers in HELM format.
        scores : array-like of float or int
            Score associated to each polymer.
        acquisition_function : `AcquisitionFunction` or list of `AcquisitionFunction` objects
            The acquisition function(s) that will be used to score the polymer.
        scaffold_designs : dictionary
            Dictionary with scaffold polymers and sets of monomers to 
            use for each position.

        Returns
        -------
        results : `pymoo.model.result.Result` or list of `pymoo.model.result.Result`
            Object or list of object containing the results of the optimization.

        """
        # Make sure that inputs are numpy arrays
        polymers = np.asarray(polymers)
        scores = np.asarray(scores)

        # Starts by automatically adjusting the input polymers to the scaffold designs
        polymers, _ = adjust_polymers_to_designs(polymers, scaffold_designs)

        # Group/cluster them by scaffold
        groups, group_indices = group_polymers_by_scaffold(polymers, return_index=True)

        # Check that all the scaffold designs are defined for all the polymers
        scaffolds_not_present = list(set(groups.keys()).difference(scaffold_designs.keys()))

        if scaffolds_not_present:
            msg_error = 'The following scaffolds are not defined: \n'
            for scaffold_not_present in scaffolds_not_present:
                msg_error += f'- {scaffold_not_present}\n'

            raise RuntimeError(msg_error)

        # Do the contrary now: check that at least one polymer is defined 
        # per scaffold. We need to generate at least one polymer per 
        # scaffold to be able to start the GA optimization. Here we 
        # generate 42 random polymers per scaffold. We do that in the
        # case we want to explore different scaffolds that are not in
        # the initial dataset.
        scaffolds_not_present = list(set(scaffold_designs.keys()).difference(groups.keys()))

        if scaffolds_not_present:
            tmp_scaffolds_designs = {key: scaffold_designs[key] for key in scaffolds_not_present}
            # We generate them
            n_polymers = [42] * len(tmp_scaffolds_designs)
            new_polymers = generate_random_polymers_from_designs(n_polymers, tmp_scaffolds_designs)
            # We score them
            new_scores = np.zeros(shape=(len(new_polymers), len(acquisition_functions)))
            for i, acq_fun in enumerate(acquisition_functions):
                new_scores[:, i] = acq_fun.forward(new_polymers).acq
            # Add them to the rest
            polymers = np.concatenate([polymers, new_polymers])
            scores = np.concatenate([scores, new_scores])
            # Recluster all of them again (easier than updating the groups)
            groups, group_indices = group_polymers_by_scaffold(polymers, return_index=True)

        seq_gao = SerialSequenceGA(**self._parameters)

        if len(group_indices) == 1:
            results = seq_gao.run(polymers, scores, acquisition_functions, scaffold_designs)
        else:
            # Take the minimal amount of CPUs needed or available
            if self._n_process == -1:
                self._n_process = min([os.cpu_count(), len(group_indices)])
            
            # Dispatch all the scaffold accross different independent Sequence GA opt.
            ray.init(num_cpus=self._n_process, ignore_reinit_error=True)

            refs = [parallel_ga.remote(seq_gao, polymers[seq_ids], scores[seq_ids], acquisition_functions, scaffold_designs) 
                    for _, seq_ids in group_indices.items()]

            try:
                results = ray.get(refs)
            except:
                ray.shutdown()
                sys.exit(0)

            ray.shutdown()

        return results
        

class RandomGA():
    """
    The RandomGA is for benchmark purpose only. It generates random polymers.

    """

    def __init__(self, n_gen=1000, n_children=500, **kwargs):
        """
        Initialize the RandomGA "optimization".

        Parameters
        ----------
        n_gen : int, default : 1000
            Number of GA generation to run.
        n_children : int, default : 500
            Number of children generated at each generation.

        """
        self.polymers = None
        self.scores = None
        # Parameters
        self._n_gen = n_gen
        self._n_children = n_children

    def run(self, polymers, scores, acquisition_function, scaffold_designs):
        """
        Run the RandomGA "optimization".

        Parameters
        ----------
        polymers : array-like of str
            Polymers in HELM format.
        scores : array-like of float or int
            Score associated to each polymer.
        acquisition_function : AcquisitionFunction (RandomImprovement)
            The acquisition function that will be used to score the polymer.
        scaffold_designs : dictionary
            Dictionary with scaffold polymers and defined set of monomers 
            to use for each position.

        Returns
        -------
        polymers : ndarray
            Polymers found during the GA search.
        scores : ndarray
            Score for each polymer found.

        """
        # Generate (n_children * n_gen) polymers and random score them!
        all_polymers = generate_random_polymers_from_designs(self._n_children * self._n_gen, scaffold_designs)
        all_scores = acquisition_function.forward(all_polymers)

        all_polymers = np.asarray(all_polymers)
        all_scores = np.asarray(all_scores)

        # Sort polymers by scores in the decreasing order (best to worst)
        # The scores are scaled to be sure that the best has the lowest score
        # This scaling factor is based on the acquisition function nature
        sorted_indices = np.argsort(acquisition_function.scaling_factor * scores)

        self.polymers = all_polymers[sorted_indices]
        self.scores = all_scores[sorted_indices]

        print(f'End RandomGA - Best score: {self.scores[0]:5.3f}'
              f' - {self.polymers[0]} ({self.polymers[0].count(".")})')

        return self.polymers, self.scores
